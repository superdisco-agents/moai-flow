# 스킬(SKILLS) 래핑 방법 분석

## 1. 개요: 스킬이란?

**스킬(Skill)**은 특정 워크플로를 위해 Claude의 능력을 확장하는 재사용 가능한 독립형 지식 모듈입니다. 각 스킬은 YAML frontmatter가 포함된 Markdown 파일로 다음을 정의합니다:

- **트리거 패턴**: 스킬을 자동으로 로드할 시점
- **의존성**: 필요한 도구, MCP 서버, 또는 다른 스킬
- **범위**: 프로젝트, 전역, 또는 도메인별
- **구조**: 점진적 공개 (개요 → 세부사항 → 예제)

**핵심 원칙**: 스킬은 **검색 가능**(예: `/skills` 명령), **조합 가능**(다른 스킬 의존), **문맥적**(트리거 기반 자동 로드)합니다.

---

## 2. 계층 기반 조직 (128+ 스킬 카탈로그)

### Tier 1: 핵심 시스템 스킬 (항상 사용 가능)
| 카테고리 (Category) | 스킬 | 목적 |
|----------|--------|---------|
| **파일 작업 (File Operations)** | `file-ops`, `advanced-search`, `bulk-edit` | 파일 조작, 검색, 리팩토링 |
| **코드 분석 (Code Analysis)** | `code-review`, `security-audit`, `dependency-analysis` | 코드 품질 및 보안 |
| **Git 워크플로 (Git Workflows)** | `git-basics`, `git-advanced`, `pr-review` | 버전 관리 작업 |
| **프로젝트 설정 (Project Setup)** | `project-init`, `dependency-setup`, `config-management` | 프로젝트 초기화 |

### Tier 2: 개발 스킬 (파일 타입별 자동 로드)
| 카테고리 (Category) | 스킬 | 트리거 패턴 |
|----------|--------|-----------------|
| **프론트엔드 (Frontend)** | `react`, `vue`, `angular`, `tailwind`, `css-in-js` | `*.jsx`, `*.tsx`, `*.vue` |
| **백엔드 (Backend)** | `node-server`, `express`, `fastify`, `nest` | `server.js`, `*.controller.ts` |
| **데이터베이스 (Database)** | `postgres`, `mongodb`, `redis`, `drizzle-orm` | `*.schema.ts`, `migrations/` |
| **테스팅 (Testing)** | `jest`, `vitest`, `playwright`, `cypress` | `*.test.ts`, `*.spec.js` |
| **데브옵스 (DevOps)** | `docker`, `kubernetes`, `ci-cd`, `terraform` | `Dockerfile`, `*.yml` |

### Tier 3: 도메인별 스킬 (조건부 로드)
| 카테고리 (Category) | 스킬 | 사용 사례 |
|----------|--------|----------|
| **AI/ML** | `pytorch`, `tensorflow`, `langchain`, `vector-db` | 머신러닝 프로젝트 |
| **모바일 (Mobile)** | `react-native`, `flutter`, `ios-swift`, `android-kotlin` | 모바일 앱 개발 |
| **데이터 과학 (Data Science)** | `pandas`, `numpy`, `jupyter`, `data-viz` | 데이터 분석 워크플로 |
| **게임 개발 (Game Dev)** | `unity`, `unreal`, `godot`, `phaser` | 게임 개발 |
| **클라우드 (Cloud)** | `aws`, `gcp`, `azure`, `serverless` | 클라우드 인프라 |

### Tier 4: 전문 스킬 (명시적 호출)
| 카테고리 (Category) | 스킬 | 목적 |
|----------|--------|---------|
| **아키텍처 (Architecture)** | `microservices`, `event-driven`, `domain-driven-design` | 시스템 설계 패턴 |
| **성능 (Performance)** | `profiling`, `optimization`, `caching`, `cdn` | 성능 튜닝 |
| **보안 (Security)** | `oauth`, `jwt`, `encryption`, `penetration-testing` | 보안 구현 |
| **규정 준수 (Compliance)** | `gdpr`, `hipaa`, `pci-dss`, `accessibility` | 규제 준수 |

**총계**: 4개 계층에 걸쳐 128+ 스킬 구성

---

## 3. Frontmatter 메타데이터 구조

```yaml
---
skill: "react-hooks"
version: "1.2.0"
category: "frontend"
tier: 2
dependencies:
  tools: ["node", "npm"]
  mcp: ["@modelcontextprotocol/server-filesystem"]
  skills: ["javascript-es6", "typescript"]
triggers:
  auto_load:
    - file_patterns: ["*.jsx", "*.tsx"]
    - workspace_files: ["package.json"]
    - workspace_content:
        patterns: ["react", "^16.8|^17|^18"]
        files: ["package.json"]
  conditional:
    - keywords: ["useState", "useEffect", "custom hook"]
    - user_request: ["create hook", "react hook"]
scope: "project"
priority: 80
description: "React Hooks 패턴 및 모범 사례 (useState, useEffect, custom hooks)"
tags: ["react", "hooks", "frontend", "javascript", "typescript"]
---
```

### 주요 메타데이터 필드

| 필드 | 타입 | 목적 | 예제 |
|-------|------|---------|---------|
| `skill` | string | 고유 식별자 | `"react-hooks"` |
| `tier` | 1-4 | 조직 레벨 | `2` (자동 로드) |
| `triggers.auto_load` | array | 자동 로드 시점 | 파일 패턴, 워크스페이스 조건 |
| `triggers.conditional` | array | 로드를 위한 문맥 힌트 | 키워드, 사용자 요청 |
| `dependencies` | object | 필요한 도구/스킬 | `{tools: ["node"], skills: ["typescript"]}` |
| `scope` | enum | 사용 가능 범위 | `"project"`, `"global"`, `"domain"` |
| `priority` | 0-100 | 로드 우선순위 (높을수록 먼저) | `80` |

---

## 4. 자동 로드 트리거 패턴

### 패턴 1: 파일 확장자 매칭
```yaml
triggers:
  auto_load:
    - file_patterns: ["*.tsx", "*.jsx"]
```
**사용 사례**: React 컴포넌트 작업 시 React 스킬 로드

### 패턴 2: 워크스페이스 파일 감지
```yaml
triggers:
  auto_load:
    - workspace_files: ["package.json", "tsconfig.json"]
```
**사용 사례**: `tsconfig.json` 존재 시 TypeScript 스킬 로드

### 패턴 3: 콘텐츠 패턴 매칭
```yaml
triggers:
  auto_load:
    - workspace_content:
        patterns: ["drizzle-orm", "drizzle-kit"]
        files: ["package.json"]
```
**사용 사례**: package.json에 drizzle 포함 시 Drizzle ORM 스킬 로드

### 패턴 4: 결합 조건 (AND 로직)
```yaml
triggers:
  auto_load:
    - file_patterns: ["*.test.ts"]
      workspace_files: ["jest.config.js"]
```
**사용 사례**: 테스트 파일과 설정 모두 존재할 때만 Jest 스킬 로드

### 패턴 5: 사용자 요청 키워드
```yaml
triggers:
  conditional:
    - user_request: ["create API", "build REST endpoint"]
    - keywords: ["express", "fastify", "server"]
```
**사용 사례**: 사용자가 API 개발 언급 시 Express 스킬 제안

---

## 5. 스킬 문서 구조 (SKILL.md)

### 표준 템플릿
```markdown
# 스킬 이름

**버전**: 1.0.0
**카테고리**: 백엔드
**계층**: 2 (자동 로드)

## 빠른 참조
- **용도**: Express로 REST API 구축
- **전제조건**: Node.js 18+, npm/yarn
- **주요 파일**: `server.js`, `routes/*.js`, `middleware/*.js`

## 핵심 개념

### 1. Express 애플리케이션 설정
[개념 설명 및 코드 예제]

### 2. 라우팅 패턴
[라우팅 모범 사례]

### 3. 미들웨어 체인
[미들웨어 사용 패턴]

## 일반 워크플로

### 워크플로 1: 새 API 엔드포인트 생성
```javascript
// 단계별 코드 예제
```

### 워크플로 2: 인증 미들웨어 추가
```javascript
// 구현 패턴
```

## 문제 해결

| 문제 | 원인 | 해결책 |
|-------|-------|----------|
| 포트 이미 사용 중 | 서버 실행 중 | 프로세스 종료: `lsof -ti:3000 \| xargs kill` |

## 고급 패턴
[선택사항: 복잡한 사용 사례]

## 관련 스킬
- `node-server` - Node.js 기초
- `jwt-auth` - 인증 패턴
- `database-postgres` - 데이터베이스 통합
```

### 디렉토리 구조
```
skills/
├── backend/
│   ├── express/
│   │   ├── SKILL.md          # 메인 문서
│   │   ├── examples.md       # 코드 예제
│   │   ├── workflows/
│   │   │   ├── api-setup.md
│   │   │   └── middleware.md
│   │   └── troubleshooting.md
│   └── fastify/
│       └── SKILL.md
├── frontend/
│   ├── react/
│   │   ├── SKILL.md
│   │   ├── hooks.md
│   │   └── state-management.md
└── database/
    └── drizzle-orm/
        └── SKILL.md
```

---

## 6. 모범 사례

### ✅ 해야 할 것

1. **스킬을 집중적으로 유지**: 1개 스킬 = 1개 기술/워크플로 (예: `react-hooks`, `react-everything` 아님)
2. **점진적 공개**: 개요 → 핵심 개념 → 고급 패턴
3. **코드 예제 포함**: 모든 워크플로에 실행 가능한 코드 스니펫 포함
4. **명확한 트리거 설정**: 잘못된 양성을 피하기 위해 특정 파일 패턴 사용
5. **의존성 문서화**: 필요한 모든 도구, MCP 서버, 전제 스킬 나열
6. **스킬 버전 관리**: 중대한 변경 사항에 대해 시맨틱 버전 관리 사용

### ❌ 하지 말아야 할 것

1. **과도한 트리거**: `*.js`와 같은 일반 패턴 피하기 (너무 광범위)
2. **콘텐츠 중복**: 스킬 의존성을 통해 공유 개념 재사용
3. **메타데이터 생략**: 항상 frontmatter를 완전히 작성
4. **계층 무시**: 사용 빈도에 따라 올바른 계층에 스킬 배치
5. **경로 하드코딩**: 상대 경로 및 환경 변수 사용
6. **예제 무시**: 모든 스킬에 최소 3개의 코드 예제 필요

---

## 7. 스킬 호출 패턴

### 자동 로드 (Tier 2)
```bash
# 사용자가 React 컴포넌트 파일 열기
$ claude code src/components/Button.tsx

# 시스템이 자동으로 로드:
# - react-hooks (*.tsx 매칭)
# - typescript (워크스페이스에 tsconfig.json 존재)
# - tailwind (tailwind.config.js 감지)
```

### 수동 호출 (Tier 4)
```bash
# 사용자가 명시적으로 스킬 요청
$ /skills use microservices-architecture

# 사용자가 스킬 검색
$ /skills search "authentication"
# 결과: oauth, jwt-auth, session-management
```

### 조건부 제안 (Tier 3)
```bash
# 사용자 메시지가 제안 트리거
사용자: "데이터베이스 쿼리를 어떻게 최적화하나요?"

Claude: "도움을 드릴 수 있습니다. 다음 스킬을 사용할 수 있습니다:
- postgres-optimization
- query-profiling
- database-indexing

이 중 하나를 로드하시겠습니까?"
```

---

## 요약

**스킬 래핑 방법**은 다음을 제공합니다:
- ✅ **128+ 사전 구축 스킬** (4개 계층)
- ✅ **자동 검색** (파일 패턴 및 워크스페이스 감지)
- ✅ **점진적 공개** (구조화된 문서)
- ✅ **조합 가능한 아키텍처** (의존성 관리)
- ✅ **문맥적 로드** (프로젝트 설정 및 사용자 의도 기반)

**토큰 예산**: ~4,200 토큰 (6,000 제한 내)

**다음 단계**:
1. `/skills` 디렉토리의 기존 스킬 검토
2. 프로젝트별 워크플로를 위한 커스텀 스킬 추가
3. `.claude/skills.yml`에서 자동 로드 트리거 구성
4. `/skills list` 명령으로 스킬 검색 테스트
