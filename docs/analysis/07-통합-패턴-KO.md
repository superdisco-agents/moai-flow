# 통합 패턴 및 모범 사례

**MOAI-ADK 시스템 통합 가이드**
*Commands → Agents → Skills → MCP 오케스트레이션*

---

## 1. 개요: 통합 흐름

```ansi
[0;36m┌─────────────────────────────────────────────────────────────┐[0m
[0;36m│[0m  [1;33mCommands[0m  →  [1;32mAgents[0m  →  [1;35mSkills[0m  →  [1;34mMCP Tools[0m  [0;36m│[0m
[0;36m└─────────────────────────────────────────────────────────────┘[0m

[1;33m/moai:1-plan[0m
    ↓
[1;32m/src/commands/plan-phase.ts[0m → [1;32mmanager-spec[0m 에이전트 호출
    ↓
[1;35m/skills/planning/[0m → 에이전트 매니페스트에 의해 자동 로드
    ↓
[1;34mmcp__serena-*__*[0m → 코드 분석 및 파일 작업
```

**핵심 원칙**: 명령어는 상위 수준 흐름을 조율하고, 에이전트는 도메인 로직을 실행하며, 스킬은 재사용 가능한 모듈을 제공하고, MCP 도구는 하위 수준 작업을 처리합니다.

---

## 2. 핵심 통합 패턴

### 패턴 1: Command → Agent → Skills 체인

```ansi
[0;32m┌──────────────────────────────────────────────────────────┐[0m
[0;32m│[0m [1m패턴: /moai:1-plan 실행 체인[0m                          [0;32m│[0m
[0;32m└──────────────────────────────────────────────────────────┘[0m

[1;33m1. 명령어 호출[0m
   /moai:1-plan "REST API 구축"
   ↓
[1;32m2. 에이전트 선택[0m (plan-phase.ts)
   agent: "manager-spec"
   task: "요구사항 분석, S.P.E.C. 생성"
   ↓
[1;35m3. 스킬 자동 로드[0m (에이전트 매니페스트)
   - /skills/planning/requirement-analyzer.md
   - /skills/planning/spec-writer.md
   ↓
[1;34m4. MCP 도구 실행[0m
   mcp__serena-1__find_symbol → 코드 분석
   mcp__serena-1__search_for_pattern → 패턴 검색
   ↓
[1;32m5. 출력[0m
   /docs/01-SPEC.md 생성
```

**구현 예제**:
```typescript
// /src/commands/plan-phase.ts
export const planPhase = {
  async execute(task: string) {
    // 1. 에이전트 호출
    const agent = await Task("manager-spec", task, "analyst");

    // 2. 매니페스트를 통해 스킬 자동 로드
    // 3. 에이전트가 내부적으로 MCP 도구 사용
    // 4. 구조화된 출력 반환
    return agent.result;
  }
};
```

---

### 패턴 2: MCP Resume 체인 (컨텍스트 보존)

```ansi
[0;36m┌──────────────────────────────────────────────────────────┐[0m
[0;36m│[0m [1m패턴: 다단계 에이전트 조정[0m                            [0;36m│[0m
[0;36m└──────────────────────────────────────────────────────────┘[0m

[1;33m단계 1: 계획 에이전트[0m
   agent_id: "agent_001"
   task: "명세서 생성"
   output: 메모리에 저장
   ↓
[1;32m단계 2: 코딩 에이전트[0m (컨텍스트 재개)
   agent_id: "agent_002"
   resume_from: "agent_001"  ← [1;31m중요[0m
   input: agent_001의 메모리 읽기
   ↓
[1;35m단계 3: 테스팅 에이전트[0m
   agent_id: "agent_003"
   resume_from: "agent_002"
   validates: agent_002의 코드 검증
```

**구현 예제**:
```typescript
// 단계 1: 계획
const planAgent = await Task(
  "manager-spec",
  "요구사항 분석",
  "analyst",
  { agent_id: "plan_001" }
);

// 단계 2: 코딩 (컨텍스트 재개)
const codeAgent = await Task(
  "manager-code",
  "plan_001 기반 구현",
  "coder",
  {
    agent_id: "code_002",
    resume_from: "plan_001"  // 컨텍스트 연결
  }
);
```

---

### 패턴 3: 작업 위임 (직접 파일 작업 금지)

```ansi
[0;31m┌──────────────────────────────────────────────────────────┐[0m
[0;31m│[0m [1m❌ 안티패턴: 직접 파일 작업[0m                          [0;31m│[0m
[0;31m└──────────────────────────────────────────────────────────┘[0m

❌ 잘못된 예:
   Command → Read("/src/file.ts")
   Command → Write("/docs/spec.md")

[0;32m┌──────────────────────────────────────────────────────────┐[0m
[0;32m│[0m [1m✅ 올바른 예: 에이전트에 위임[0m                        [0;32m│[0m
[0;32m└──────────────────────────────────────────────────────────┘[0m

✅ 올바른 예:
   Command → Task("agent", "/src/file.ts 분석")
             ↓
             Agent → MCP 도구 (Read, Write)
```

**이유**:
- 에이전트가 MCP 도구를 조정
- 스킬이 재사용 가능한 로직 제공
- 명령어는 상위 수준 유지
- 더 나은 오류 처리

---

### 패턴 4: Git 3-모드 통합

```ansi
[0;35m┌──────────────────────────────────────────────────────────┐[0m
[0;35m│[0m [1m패턴: Git 모드 선택[0m                                  [0;35m│[0m
[0;35m└──────────────────────────────────────────────────────────┘[0m

[1;33m/moai:git[0m → 사용자 선택:
   [1] Manual: 사용자가 git 명령어 직접 처리
   [2] Personal: 자동으로 feature 브랜치에 커밋
   [3] Team: PR 생성하여 리뷰 요청

[1;32mManual 모드[0m:
   - 자동 커밋 없음
   - 사용자가 직접 실행: git add, git commit, git push

[1;34mPersonal 모드[0m:
   - 자동: git checkout -b feature/moai-<task>
   - 자동: git commit -am "feat: <description>"
   - 자동: git push origin feature/moai-<task>

[1;35mTeam 모드[0m:
   - Personal 모드의 모든 작업
   - 자동: gh pr create --title "..." --body "..."
   - PR 리뷰 대기
```

**구현 예제**:
```typescript
// /src/commands/git-command.ts
export const gitCommand = {
  async execute(mode: "manual" | "personal" | "team") {
    if (mode === "manual") {
      return "Git 명령어 준비 완료. 워크플로우를 직접 제어하세요.";
    }

    if (mode === "personal") {
      await Bash("git checkout -b feature/moai-$(date +%s)");
      await Bash("git commit -am 'feat: 자동 커밋'");
      await Bash("git push origin HEAD");
    }

    if (mode === "team") {
      // ... personal 모드 단계 ...
      await Bash("gh pr create --fill");
    }
  }
};
```

---

## 3. 모범 사례

| 사례 | 설명 | 예제 |
|------|------|------|
| **1. 단일 책임** | 각 명령어는 한 가지만 수행 | `/moai:1-plan` → 계획만 수행 |
| **2. 에이전트 조합** | 복잡한 작업에는 여러 에이전트 사용 | Plan → Code → Test 체인 |
| **3. 모듈형 스킬** | `/skills`의 재사용 가능한 로직 | `requirement-analyzer.md` |
| **4. MCP 추상화** | 에이전트가 MCP 도구 래핑 | Agent → `find_symbol()` (Command 직접 호출 금지) |
| **5. 오류 경계** | 명령어 수준의 try/catch | 명령어가 에이전트 오류 캐치 |
| **6. 컨텍스트 전달** | `agent_id`와 `resume_from` 사용 | 다단계 워크플로우 |
| **7. 병렬 실행** | 독립적인 작업 일괄 처리 | TodoWrite로 모든 todo 한 번에 |
| **8. 파일 구조화** | 루트에 저장 금지 | `/docs`, `/src`, `/tests` 사용 |
| **9. 메모리 관리** | MCP 메모리에 에이전트 상태 저장 | 단계 간 컨텍스트 공유 |
| **10. 멱등성** | 명령어 여러 번 실행 가능 | `/moai:1-plan` 재실행 안전 |
| **11. 점진적 향상** | 명령어가 서로 기반 구축 | 1-plan → 2-code → 3-test |
| **12. 문서 우선** | 스킬이 자체 문서화 | 마크다운 기반 스킬 |

---

## 4. 일반적인 안티패턴

### ❌ 안티패턴 1: 명령어 비대화
```typescript
// ❌ 잘못된 예: 명령어가 모든 것을 수행
export const megaCommand = {
  async execute() {
    await Read("/src/file.ts");
    await Write("/docs/spec.md");
    await Bash("npm test");
    await Task("agent", "...");
  }
};

// ✅ 올바른 예: 명령어가 에이전트 조율
export const smartCommand = {
  async execute() {
    await Task("spec-agent", "분석 및 문서화");
    await Task("test-agent", "검증 실행");
  }
};
```

### ❌ 안티패턴 2: 스킬 중복
```typescript
// ❌ 잘못된 예: 여러 스킬에 동일한 로직
/skills/planning/analyzer-v1.md
/skills/planning/analyzer-v2.md
/skills/coding/analyzer.md

// ✅ 올바른 예: 공유 스킬 모듈
/skills/shared/code-analyzer.md → 모든 에이전트가 사용
```

### ❌ 안티패턴 3: Resume 체인 끊김
```typescript
// ❌ 잘못된 예: 컨텍스트 연결 없음
const agent1 = await Task("plan", "...");
const agent2 = await Task("code", "..."); // 컨텍스트 손실!

// ✅ 올바른 예: 컨텍스트 보존
const agent1 = await Task("plan", "...", { agent_id: "p1" });
const agent2 = await Task("code", "...", { resume_from: "p1" });
```

### ❌ 안티패턴 4: 명령어에서 MCP 직접 사용
```typescript
// ❌ 잘못된 예: 명령어가 MCP 직접 사용
await mcp__serena_1__find_symbol({ name_path: "MyClass" });

// ✅ 올바른 예: 에이전트가 MCP 사용
await Task("analyzer", "MyClass 심볼 찾기");
```

### ❌ 안티패턴 5: 루트 파일 오염
```typescript
// ❌ 잘못된 예: 루트의 파일들
/test-file.md
/my-notes.txt
/temp-analysis.json

// ✅ 올바른 예: 구조화된 파일
/docs/analysis.md
/tests/integration.test.ts
/_config/temp-notes.txt
```

### ❌ 안티패턴 6: 순차 실행 (병렬이어야 함)
```typescript
// ❌ 잘못된 예: 순차 실행
await Task("agent1", "...");
await Task("agent2", "...");
await TodoWrite({ todos: [todo1] });
await TodoWrite({ todos: [todo2] });

// ✅ 올바른 예: 병렬 실행
await Promise.all([
  Task("agent1", "..."),
  Task("agent2", "..."),
  TodoWrite({ todos: [todo1, todo2] })
]);
```

---

## 5. 실전 예제

### 예제 1: 전체 SPARC 워크플로우

```typescript
// /moai:full-stack "사용자 인증 구축"

// 단계 1: 계획 (/moai:1-plan)
const spec = await Task(
  "manager-spec",
  "인증 요구사항 분석, S.P.E.C. 생성",
  "analyst",
  {
    agent_id: "auth_spec_001",
    skills: ["requirement-analyzer", "spec-writer"]
  }
);
// 출력: /docs/01-SPEC.md

// 단계 2: 의사코드 (/moai:2-pseudo)
const pseudo = await Task(
  "manager-pseudo",
  "auth_spec_001 기반 인증 알고리즘 설계",
  "architect",
  {
    agent_id: "auth_pseudo_002",
    resume_from: "auth_spec_001"
  }
);
// 출력: /docs/02-PSEUDOCODE.md

// 단계 3: 아키텍처 (/moai:3-arch)
const arch = await Task(
  "manager-arch",
  "인증 시스템 아키텍처 설계",
  "system-architect",
  {
    agent_id: "auth_arch_003",
    resume_from: "auth_pseudo_002"
  }
);
// 출력: /docs/03-ARCHITECTURE.md

// 단계 4: 개선 (/moai:4-refine)
const code = await Task(
  "manager-code",
  "아키텍처 기반 인증 구현",
  "coder",
  {
    agent_id: "auth_code_004",
    resume_from: "auth_arch_003"
  }
);
// 출력: /src/auth/login.ts, /src/auth/register.ts

// 단계 5: 완료 (/moai:5-complete)
const tests = await Task(
  "manager-test",
  "인증 구현 검증",
  "tester",
  {
    agent_id: "auth_test_005",
    resume_from: "auth_code_004"
  }
);
// 출력: /tests/auth.test.ts
```

**주요 특징**:
- 각 단계가 이전 컨텍스트 재개
- 에이전트 매니페스트별로 스킬 자동 로드
- 적절한 디렉토리에 파일 구조화
- 에이전트 뒤에 추상화된 MCP 도구

---

### 예제 2: 병렬 에이전트 조정

```typescript
// /moai:parallel-dev "API + 프론트엔드 + 테스트 구축"

// 모든 에이전트 동시 실행
await Promise.all([
  Task(
    "backend-dev",
    "인증 훅이 있는 REST API 구축",
    "coder",
    { agent_id: "api_001" }
  ),

  Task(
    "frontend-dev",
    "React UI 생성 (계약을 위해 api_001에서 재개)",
    "coder",
    { agent_id: "ui_002", resume_from: "api_001" }
  ),

  Task(
    "test-engineer",
    "통합 테스트 작성 (api_001 + ui_002 감시)",
    "tester",
    {
      agent_id: "tests_003",
      resume_from: ["api_001", "ui_002"]
    }
  ),

  TodoWrite({
    todos: [
      { id: "1", content: "API 엔드포인트", status: "in_progress" },
      { id: "2", content: "React 컴포넌트", status: "in_progress" },
      { id: "3", content: "통합 테스트", status: "in_progress" },
      { id: "4", content: "API 문서화", status: "pending" }
    ]
  })
]);
```

**장점**:
- 순차 실행보다 3배 빠름
- `resume_from`을 통한 에이전트 조정
- 단일 호출로 일괄 처리된 todo
- 실시간 진행 상황 추적

---

### 예제 3: Git 팀 워크플로우

```typescript
// /moai:git team

// 워크플로우:
// 1. feature 브랜치 생성
await Bash("git checkout -b feature/moai-auth-$(date +%s)");

// 2. 에이전트가 변경 수행
await Task(
  "manager-code",
  "사용자 인증 구현",
  "coder"
);

// 3. 자동 커밋
await Bash("git add .");
await Bash("git commit -m 'feat: JWT를 사용한 사용자 인증 추가'");

// 4. 원격 저장소에 푸시
await Bash("git push origin HEAD");

// 5. PR 생성
await Bash(`
  gh pr create \
    --title "feat: 사용자 인증 시스템" \
    --body "로그인/등록 엔드포인트가 있는 JWT 기반 인증 구현" \
    --label "enhancement"
`);

// 6. 사용자 알림
console.log("✅ PR 생성 완료! 팀 리뷰 대기 중...");
```

---

## 6. 통합 체크리스트

새 명령어/에이전트/스킬 배포 전:

- [ ] 명령어가 에이전트에 위임 (MCP 직접 호출 금지)
- [ ] 에이전트가 `/skills` 디렉토리에서 스킬 로드
- [ ] 스킬이 모듈화되고 재사용 가능
- [ ] 에이전트 로직이 MCP 도구 래핑
- [ ] `/src`, `/docs`, `/tests`에 파일 구조화 (루트 금지)
- [ ] Resume 체인이 `agent_id` + `resume_from` 사용
- [ ] 병렬 작업이 단일 메시지로 일괄 처리
- [ ] 명령어 수준의 오류 처리
- [ ] `/docs`의 문서 업데이트
- [ ] Git 모드 선택 (manual/personal/team)

---

## 7. 성능 최적화

### 최적화 1: MCP 호출 일괄 처리
```typescript
// ❌ 느림: 순차 MCP 호출
await mcp__serena_1__find_symbol({ name_path: "Class1" });
await mcp__serena_1__find_symbol({ name_path: "Class2" });

// ✅ 빠름: 단일 에이전트 호출이 내부적으로 일괄 처리
await Task("analyzer", "Class1, Class2, Class3 심볼 찾기");
```

### 최적화 2: 병렬 에이전트 실행
```typescript
// ❌ 느림: 12초 (4초 × 3 에이전트)
await Task("agent1", "...");
await Task("agent2", "...");
await Task("agent3", "...");

// ✅ 빠름: 4초 (병렬 실행)
await Promise.all([
  Task("agent1", "..."),
  Task("agent2", "..."),
  Task("agent3", "...")
]);
```

### 최적화 3: 스킬 캐싱
```typescript
// 에이전트 세션당 한 번만 로드되는 스킬
// 후속 호출은 로드된 스킬 재사용
const agent = await Task("manager-spec", "...");
// 스킬: requirement-analyzer.md, spec-writer.md 로드됨

// 다음 호출은 동일한 스킬 재사용
const agent2 = await Task("manager-spec", "...");
// 재로드 불필요
```

---

**최종 업데이트**: 2025년 11월 28일
**상태**: 프로덕션 준비 완료 ✅
**토큰 수**: ~5,800 토큰
